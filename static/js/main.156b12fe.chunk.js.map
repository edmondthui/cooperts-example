{"version":3,"sources":["components/card/index.tsx","components/card-column/index.tsx","components/create-card/index.tsx","components/card-columns/index.tsx","store/index.ts","store/Types.ts","utils/kanban.utils.ts","store/ReactionComponent.tsx","store/Reaction.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["observer","card","index","draggableId","id","provided","snapshot","className","draggableProps","dragHandleProps","ref","innerRef","style","isDragging","draggableStyle","transform","description","cards","status","droppableId","droppableProps","map","key","placeholder","customStyles","content","top","left","right","bottom","marginRight","width","height","boxShadow","Modal","setAppElement","onStringChange","store","e","setCreateString","target","value","openModal","createString","preventDefault","trim","length","toggleModal","closeModal","handleSubmit","name","getOrElseValue","Task","fromPromise","db","addCard","fork","err","console","log","success","newCard","Object","assign","statusHandler","setStatus","CreateCard","this","props","isOpen","modalOpen","onRequestClose","contentLabel","onSubmit","onChange","disabled","maxLength","React","Component","onDragEnd","result","destination","source","todo","inProgress","done","assertNever","x","Error","Store","state","kind","just","nothing","open","message","observable","action","previous","undefined","loading","data","ready","string","flat","filter","computed","connectToKanbanDB","KanbanDB","connect","getCards","obj","ReactionComponent","tester","effect","comparer","default","running","fireImmediately","delay","debounceDelay","equals","run","reaction","options","loadDB","Reactions","load","succeed","do","andThen","setCards","App","Reaction","Boolean","window","location","hostname","match","ReactDOM","createRoot","document","getElementById","render","navigator","serviceWorker","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.156b12fe.chunk.js","sourcesContent":["import { observer } from \"mobx-react\";\nimport React from \"react\";\nimport { Draggable } from \"react-beautiful-dnd\";\nimport \"./card.styles.css\";\nimport Store from \"../../store\";\n\ninterface Props {\n  card: any;\n  index: number;\n}\n\nconst getCardStyle = (isDragging: any, draggableStyle: any) => {\n  if (isDragging && draggableStyle.transform !== null)\n    draggableStyle.transform += \" rotate(10deg)\";\n  return { ...draggableStyle };\n};\n\n// const handleDelete = () => {\n//   connectToKanbanDB().then((db, dbInstanceId) => {\n//     db.deleteCardById(cardId).then((bool) =>\n//       console.log(`successfully deleted card ${bool}`)\n//     );\n\n//     setCardId(\"\");\n//     updateCards();\n//     closeModal();\n//   });\n// };\n// will probably make a new droppable garbage can component that will handle delete\n\nconst Card: React.FC<Props> = ({ card, index }) => (\n  <Draggable draggableId={card.id} index={index}>\n    {(provided, snapshot) => (\n      <div\n        className=\"card\"\n        {...provided.draggableProps}\n        {...provided.dragHandleProps}\n        ref={provided.innerRef}\n        id={card.id}\n        style={getCardStyle(snapshot.isDragging, provided.draggableProps.style)}\n      >\n        {card.description}\n      </div>\n    )}\n  </Draggable>\n);\n\nexport default observer(Card);\n","import * as React from \"react\";\nimport \"./card-column.styles.css\";\nimport { Droppable } from \"react-beautiful-dnd\";\nimport Card from \"../card\";\nimport { observer } from \"mobx-react\";\n\ninterface Props {\n  cards: Array<any>;\n  status: string;\n}\n\nconst CardColumn: React.FC<Props> = ({ cards, status }) => (\n  <Droppable droppableId={status}>\n    {(provided) => (\n      <div\n        ref={provided.innerRef}\n        className=\"card-column\"\n        {...provided.droppableProps}\n      >\n        {cards.map((card, index) => {\n          return <Card card={card} index={index} key={card.id} />;\n        })}\n        {provided.placeholder}\n      </div>\n    )}\n  </Droppable>\n);\n\nexport default observer(CardColumn);\n","import { Maybe } from \"maybeasy\";\nimport { observer } from \"mobx-react\";\nimport React from \"react\";\nimport Modal from \"react-modal\";\nimport Task from \"taskarian\";\nimport Store from \"../../store\";\nimport \"./create-card.styles.css\";\n\ninterface Props {\n  store: Store;\n  createString: Maybe<string>;\n}\n\nconst customStyles = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n    width: \"50%\",\n    height: \"25%\",\n    boxShadow: \"0px 2px 5px 5px rgba(0, 0, 0, 0.1)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\n\nconst onStringChange =\n  (store: Store) => (e: React.ChangeEvent<HTMLInputElement>) => {\n    store.setCreateString(e.target.value);\n  };\n\nconst openModal = (store: Store, createString: string) => (e: any) => {\n  e.preventDefault();\n  if (createString.trim().length) {\n    store.toggleModal(true);\n  }\n};\n\nconst closeModal = (store: Store) => (e: any) => {\n  store.toggleModal(false);\n};\n\nconst handleSubmit =\n  (store: Store) => (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    let card = {\n      name: store.createString.getOrElseValue(\"\"),\n      description: store.createString.getOrElseValue(\"\"),\n      status: store.status,\n    };\n    if (card.status.length > 0) {\n      Task.fromPromise(() => store.db.addCard(card)).fork(\n        (err) => console.log(err),\n        (success) => {\n          const newCard = Object.assign({ id: success }, card);\n          store.addCard(newCard);\n        }\n      );\n    } else {\n      console.log(\"status required!\");\n      // store.error({ message: \"Card status required!\" });\n    }\n  };\n\nconst statusHandler =\n  (store: Store) => (e: React.ChangeEvent<HTMLSelectElement>) => {\n    store.setStatus(e.target.value);\n  };\n\nclass CreateCard extends React.Component<Props> {\n  render() {\n    const store = this.props.store;\n    return (\n      <div className=\"create-card\">\n        <Modal\n          isOpen={store.modalOpen}\n          onRequestClose={closeModal(store)}\n          style={customStyles}\n          contentLabel=\"Create Card Modal\"\n        >\n          <form onSubmit={handleSubmit(store)} className=\"modal-form\">\n            <select onChange={statusHandler(store)} value={store.status}>\n              <option value=\"\" disabled>\n                SELECT STATUS\n              </option>\n              <option value=\"TODO\">To-do</option>\n              <option value=\"IN_PROGRESS\">In Progress</option>\n              <option value=\"DONE\">Done</option>\n            </select>\n            <button>CREATE CARD</button>\n          </form>\n        </Modal>\n        <form\n          onSubmit={openModal(store, store.createString.getOrElseValue(\"\"))}\n          className=\"create-card-form\"\n        >\n          <input\n            onChange={onStringChange(store)}\n            value={this.props.createString.getOrElseValue(\"\")}\n            placeholder=\"e.g. Bug: TextPoll not dispatching half stars\"\n            maxLength={500}\n          />\n          <button>ADD NEW</button>\n        </form>\n      </div>\n    );\n  }\n}\n\nexport default observer(CreateCard);\n","import React from \"react\";\nimport \"./card-columns.styles.css\";\nimport { observer } from \"mobx-react\";\nimport { Maybe } from \"maybeasy\";\nimport CardColumn from \"../card-column\";\nimport CreateCard from \"../create-card\";\nimport { DragDropContext } from \"react-beautiful-dnd\";\nimport Store from \"../../store\";\n\ninterface Props {\n  store: Store;\n  createString: Maybe<string>;\n}\n\n// const onDragEnd = (result: any) => {\n//   const { destination, source } = result;\n//   if (!destination) {\n//     return;\n//   }\n//   if (\n//     destination.droppableId === source.droppableId &&\n//     destination.index === source.index\n//   ) {\n//     return;\n//   }\n// };\n\nconst onDragEnd = (store: Store) => (result: any) => {\n  const { destination, source } = result;\n  if (!destination) {\n    return;\n  }\n  if (\n    destination.droppableId === source.droppableId &&\n    destination.index === source.index\n  ) {\n    return;\n  }\n\n  const column = source.droppableId;\n  console.log(store);\n  console.log(result);\n  // const newCards = Array.from(this.state[column]);\n\n  if (destination.droppableId === source.droppableId) {\n    // const card = newCards.splice(source.index, 1);\n    // // Database does not keep track of index so it just updates this on the front end\n    // newCards.splice(destination.index, 0, ...card);\n    // this.setState(() => {\n    //   return { [destination.droppableId]: newCards };\n    // });\n  }\n\n  if (destination.droppableId !== source.droppableId) {\n    // const card = newCards[source.index];\n    // card.status = destination.droppableId;\n    // newCards.splice(source.index, 1);\n    // const destinationCards = Array.from(this.state[destination.droppableId]);\n    // destinationCards.splice(destination.index, 0, card);\n    // this.setState(() => {\n    //   return {\n    //     [destination.droppableId]: destinationCards,\n    //     [source.droppableId]: newCards,\n    //   };\n    // });\n    // connectToKanbanDB().then((db, dbInstanceId) => {\n    //   db.updateCardById(card.id, { status: destination.droppableId });\n    // });\n  }\n};\n\nconst CardColumns: React.FC<Props> = ({ store, createString }) => {\n  return (\n    <div className=\"App\">\n      <div className=\"columns-container\">\n        <DragDropContext onDragEnd={onDragEnd(store)}>\n          <div className=\"column-container\">\n            <h1 className=\"column-title\">To-do</h1>\n            <CardColumn cards={store.todo} status=\"TODO\" />\n          </div>\n          <div className=\"column-container\">\n            <h1 className=\"column-title\">In Progress</h1>\n            <CardColumn cards={store.inProgress} status=\"IN_PROGRESS\" />\n          </div>\n          <div className=\"column-container\">\n            <h1 className=\"column-title\">Done</h1>\n            <CardColumn cards={store.done} status=\"DONE\" />\n          </div>\n          <CreateCard store={store} createString={createString} />\n        </DragDropContext>\n      </div>\n    </div>\n  );\n};\n\nexport default observer(CardColumns);\n\n// constructor() {\n//   super();\n//   this.state = {\n//     TODO: [],\n//     IN_PROGRESS: [],\n//     DONE: [],\n//   };\n\n//   this.updateCards = this.updateCards.bind(this);\n// }\n\n// componentDidMount() {\n//   this.updateCards();\n// }\n\n// updateCards = async () => {\n//   connectToKanbanDB().then((db, dbInstanceId) => {\n//     db.getCards()\n//       .then((cards) => {\n//         const todos = cards.slice().filter((card) => card.status === \"TODO\");\n//         const inProgress = cards\n//           .slice()\n//           .filter((card) => card.status === \"IN_PROGRESS\");\n//         const done = cards.slice().filter((card) => card.status === \"DONE\");\n//         this.setState(() => {\n//           return {\n//             TODO: todos,\n//             IN_PROGRESS: inProgress,\n//             DONE: done,\n//           };\n//         });\n//       })\n//       .catch((err) => {\n//         if (err.message === \"No data found.\") {\n//           this.setState(() => {\n//             return {\n//               TODO: [],\n//               IN_PROGRESS: [],\n//               DONE: [],\n//             };\n//           });\n//         }\n//       });\n//   });\n// };\n\n//   const column = source.droppableId;\n//   const newCards = Array.from(this.state[column]);\n\n//   if (destination.droppableId === source.droppableId) {\n//     const card = newCards.splice(source.index, 1);\n//     // Database does not keep track of index so it just updates this on the front end\n//     newCards.splice(destination.index, 0, ...card);\n//     this.setState(() => {\n//       return { [destination.droppableId]: newCards };\n//     });\n//   }\n\n//   if (destination.droppableId !== source.droppableId) {\n//     const card = newCards[source.index];\n//     card.status = destination.droppableId;\n//     newCards.splice(source.index, 1);\n//     const destinationCards = Array.from(this.state[destination.droppableId]);\n//     destinationCards.splice(destination.index, 0, card);\n//     this.setState(() => {\n//       return {\n//         [destination.droppableId]: destinationCards,\n//         [source.droppableId]: newCards,\n//       };\n//     });\n//     connectToKanbanDB().then((db, dbInstanceId) => {\n//       db.updateCardById(card.id, { status: destination.droppableId });\n//     });\n//   }\n// };\n\n// render() {\n//   const { TODO, IN_PROGRESS, DONE } = this.state;\n//   return (\n//     <div className=\"App\">\n//       <div className=\"columns-container\">\n//         <DragDropContext onDragEnd={this.onDragEnd}>\n//           <div className=\"column-container\">\n//             <h1 className=\"column-title\">To-do</h1>\n//             <CardColumn\n//               cards={TODO}\n//               status=\"TODO\"\n//               updateCards={this.updateCards}\n//             />\n//           </div>\n//           <div className=\"column-container\">\n//             <h1 className=\"column-title\">In Progress</h1>\n//             <CardColumn\n//               cards={IN_PROGRESS}\n//               status=\"IN_PROGRESS\"\n//               updateCards={this.updateCards}\n//             />\n//           </div>\n//           <div className=\"column-container\">\n//             <h1 className=\"column-title\">Done</h1>\n//             <CardColumn\n//               cards={DONE}\n//               status=\"DONE\"\n//               updateCards={this.updateCards}\n//             />\n//           </div>\n//           <CreateCard updateCards={this.updateCards} />\n//         </DragDropContext>\n//       </div>\n//     </div>\n//   );\n// }\n","import { action, computed, observable } from \"mobx\";\nimport { just, Maybe, nothing } from \"maybeasy\";\nimport { error, loading, ready, State, waiting } from \"./Types\";\n\nexport const assertNever = (x: never) => {\n  throw new Error(`Unexpected object: ${x}`);\n};\n\nclass Store {\n  @observable\n  state: State = waiting();\n\n  @action\n  load = () => {\n    switch (this.state.kind) {\n      case \"waiting\":\n        this.state = loading(this.state);\n        break;\n      case \"ready\":\n      case \"loading\":\n      case \"error\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  ready = (data: any) => {\n    switch (this.state.kind) {\n      case \"ready\":\n      case \"error\":\n      case \"waiting\":\n        break;\n      case \"loading\":\n        console.log(data);\n        this.state.db = data.db;\n        this.state = ready(this.state);\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  error = (err: any) => {\n    this.state = error(\n      `Request failed due to '${err.kind}'. Please try again later.`\n    );\n  };\n\n  @action\n  setCreateString = (string: string) => {\n    switch (this.state.kind) {\n      case \"ready\":\n        this.state.createString = string;\n        break;\n      case \"error\":\n      case \"waiting\":\n      case \"loading\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  toggleModal = (isOpen: boolean) => {\n    switch (this.state.kind) {\n      case \"ready\":\n        console.log(\"toggle\");\n        console.log(isOpen);\n        this.state.open = isOpen;\n        break;\n      case \"error\":\n      case \"waiting\":\n      case \"loading\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  setStatus = (status: string) => {\n    switch (this.state.kind) {\n      case \"ready\":\n        this.state.status = status;\n        break;\n      case \"error\":\n      case \"waiting\":\n      case \"loading\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  addCard = (card: any) => {\n    switch (this.state.kind) {\n      case \"ready\":\n        switch (card.status) {\n          case \"TODO\":\n            this.state.todo = [...this.state.todo, card].flat();\n            break;\n          case \"IN_PROGRESS\":\n            this.state.inProgress = [...this.state.inProgress, card].flat();\n            break;\n          case \"DONE\":\n            this.state.done = [...this.state.done, card].flat();\n            break;\n        }\n        this.state.open = false;\n        this.state.createString = \"\";\n        break;\n      case \"error\":\n      case \"waiting\":\n      case \"loading\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @action\n  setCards = (cards: any) => {\n    switch (this.state.kind) {\n      case \"ready\":\n        this.state.todo = cards.filter((card: any) => card.status === \"TODO\");\n        this.state.inProgress = cards.filter(\n          (card: any) => card.status === \"IN_PROGRESS\"\n        );\n        this.state.done = cards.filter((card: any) => card.status === \"DONE\");\n        this.state.open = false;\n        this.state.createString = \"\";\n        break;\n      case \"error\":\n      case \"waiting\":\n      case \"loading\":\n        break;\n      default:\n        assertNever(this.state);\n    }\n  };\n\n  @computed\n  get createString(): Maybe<string> {\n    switch (this.state.kind) {\n      case \"ready\":\n      case \"loading\":\n        return just(this.state.createString);\n      case \"waiting\":\n      case \"error\":\n      default:\n        return nothing();\n    }\n  }\n\n  @computed\n  get status(): string {\n    switch (this.state.kind) {\n      case \"ready\":\n      case \"loading\":\n        return this.state.status;\n      case \"waiting\":\n      case \"error\":\n      default:\n        return \"\";\n    }\n  }\n\n  @computed\n  get modalOpen(): boolean {\n    switch (this.state.kind) {\n      case \"ready\":\n      case \"loading\":\n        return this.state.open;\n      case \"waiting\":\n      case \"error\":\n      default:\n        return false;\n    }\n  }\n\n  @computed\n  get errorMessage(): Maybe<string> {\n    switch (this.state.kind) {\n      case \"error\":\n        return just(this.state.message);\n      case \"ready\":\n      case \"loading\":\n      case \"waiting\":\n      default:\n        return nothing();\n    }\n  }\n\n  @computed\n  get todo(): Array<any> {\n    switch (this.state.kind) {\n      case \"ready\":\n        console.log(this.state.todo);\n        return this.state.todo;\n      case \"error\":\n      case \"loading\":\n      case \"waiting\":\n      default:\n        return [];\n    }\n  }\n\n  @computed\n  get inProgress(): Array<any> {\n    switch (this.state.kind) {\n      case \"ready\":\n        return this.state.inProgress;\n      case \"error\":\n      case \"loading\":\n      case \"waiting\":\n      default:\n        return [];\n    }\n  }\n\n  @computed\n  get done(): Array<any> {\n    switch (this.state.kind) {\n      case \"ready\":\n        return this.state.done;\n      case \"error\":\n      case \"loading\":\n      case \"waiting\":\n      default:\n        return [];\n    }\n  }\n\n  @computed\n  get db(): any {\n    switch (this.state.kind) {\n      case \"ready\":\n        return this.state.db;\n      case \"loading\":\n      case \"waiting\":\n      case \"error\":\n      default:\n        return false;\n    }\n  }\n}\n\nexport default Store;\n","import { Resource } from \"../exo_modules/Resource/Types/index\";\n\nexport interface Card {\n  id: string;\n  name: string;\n  description: string;\n  status: CardType;\n  created: Date; // UNIX timestamp\n  lastUpdated: Date; // UNIX timestamp\n}\n\nexport type CardResource = Resource<Card>;\n\nexport type CardArrayResource = Resource<Card[]>;\n\nexport type CardType = \"TODO\" | \"DONE\" | \"IN_PROGRESS\";\n\nexport const waiting = (): Waiting => ({\n  kind: \"waiting\",\n});\n\nexport const loading = (state: Waiting | Ready | Loading): Loading => {\n  const { kind, ...previous } = state;\n  return {\n    kind: \"loading\",\n    ...previous,\n    createString: \"\",\n    open: false,\n    status: \"\",\n    todo: [],\n    inProgress: [],\n    done: [],\n    db: undefined,\n  };\n};\n\nexport const ready = (state: Loading | Ready): Ready => {\n  const { kind, ...previous } = state;\n  return {\n    kind: \"ready\",\n    ...previous,\n  };\n};\n\nexport const error = (message: string): Error => ({\n  kind: \"error\",\n  message,\n});\n\ninterface Waiting {\n  kind: \"waiting\";\n}\n\nexport interface Loading {\n  kind: \"loading\";\n  createString: string;\n  todo: Array<any>;\n  inProgress: Array<any>;\n  done: Array<any>;\n  db: any;\n  open: boolean;\n  status: string;\n}\n\ninterface Ready {\n  kind: \"ready\";\n  todo: Array<any>;\n  inProgress: Array<any>;\n  done: Array<any>;\n  db: any;\n  createString: string;\n  open: boolean;\n  status: string;\n}\n\ninterface Error {\n  kind: \"error\";\n  message: string;\n}\n\nexport type State = Waiting | Loading | Ready | Error;\n","import KanbanDB from \"kanbandb\";\nimport Task from \"taskarian\";\n\nexport const connectToKanbanDB = async () => {\n  const db = await KanbanDB.connect(\"testDB\");\n  return db;\n};\n\nexport const getCards = (obj: any) => {\n  return Task.fromPromise(() => obj.db.getCards());\n};\n","import { comparer, IReactionDisposer, IReactionOptions, IReactionPublic, reaction } from 'mobx';\nimport * as React from 'react';\n\nexport interface ReactState {}\n\nexport interface RCProps<Store> {\n  store: Store;\n  fireImmediately?: boolean;\n  debounceDelay?: number;\n}\n\nexport type ReactionComparer<ObservedState> = (\n  prev: ObservedState,\n  current: ObservedState\n) => boolean;\n\nabstract class ReactionComponent<\n  Store,\n  ObservedState,\n  P extends RCProps<Store>\n> extends React.Component<P, ReactState> {\n  protected abstract tester: (r?: IReactionPublic) => ObservedState;\n  protected abstract effect: (arg: ObservedState, r?: IReactionPublic) => void;\n\n  /**\n   * Provides logic that determines if the watched value has changed. The default behavior\n   * is to use mobx's default compare, which is a slighty enhanced identity compare.\n   */\n  protected comparer: ReactionComparer<ObservedState> = comparer.default;\n\n  private running?: IReactionDisposer;\n\n  private get options(): IReactionOptions | undefined {\n    return {\n      fireImmediately: this.props.fireImmediately,\n      delay: this.props.debounceDelay,\n      equals: this.comparer,\n    };\n  }\n\n  constructor(props: P) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {\n    this.running = this.run();\n  }\n\n  componentWillUnmount() {\n    if (this.running) {\n      this.running();\n    }\n  }\n\n  render() {\n    return <></>;\n  }\n\n  private run(): IReactionDisposer {\n    return reaction(this.tester, this.effect, this.options);\n  }\n}\n\nexport default ReactionComponent;\n","import { observer } from \"mobx-react\";\nimport Task from \"taskarian\";\nimport { connectToKanbanDB, getCards } from \"../utils/kanban.utils\";\nimport Store, { assertNever } from \"./index\";\nimport ReactionComponent, { RCProps } from \"./ReactionComponent\";\nimport { State } from \"./Types\";\n// import { cardArrayResourceDecoder } from \"./Decoders\";\n\ninterface Props extends RCProps<Store> {\n  store: Store;\n}\n\nconst loadDB = () => {\n  return Task.fromPromise(connectToKanbanDB);\n};\n\nclass Reactions extends ReactionComponent<Store, State, Props> {\n  tester = () => this.props.store.state;\n  effect = (state: State) => {\n    const { store } = this.props;\n    switch (state.kind) {\n      case \"waiting\":\n        store.load();\n        break;\n      case \"loading\":\n        Task.succeed<any, {}>({})\n          .assign(\"db\", loadDB)\n          .do(({ db }) => store.ready({ db: db }))\n          .andThen(getCards)\n          .do((cards) => store.setCards(cards))\n          .fork(\n            (err) => console.log(err),\n            (success) => console.log(success)\n          );\n        break;\n      case \"ready\":\n      case \"error\":\n        break;\n      default:\n        assertNever(state);\n    }\n  };\n}\n\nexport default observer(Reactions);\n","import { observer } from \"mobx-react\";\nimport * as React from \"react\";\nimport \"./App.css\";\nimport CardColumns from \"./components/card-columns\";\nimport Store from \"./store\";\nimport Reactions from \"./store/Reaction\";\n\ninterface Props {}\n\nclass App extends React.Component<Props> {\n  store = new Store();\n\n  render() {\n    console.log(this.store.state.kind);\n    console.log(this.store);\n    return (\n      <>\n        <CardColumns\n          store={this.store}\n          createString={this.store.createString}\n        />\n        <Reactions store={this.store} fireImmediately={true} />\n      </>\n    );\n  }\n}\n\nexport default observer(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config: any) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string | URL, config: { onUpdate: (arg0: ServiceWorkerRegistration) => void; onSuccess: (arg0: ServiceWorkerRegistration) => void; }) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string | URL, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\") as HTMLElement\n);\n\nroot.render(<App />);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}